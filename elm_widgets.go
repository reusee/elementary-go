package elm // generated by elm.go

//#include <Elementary.h>
import "C"
import (
  "unsafe"
)

type EvasObject interface {
  GetObj() *C.Evas_Object
}

type Icon struct { obj *C.Evas_Object }
func (self *Icon) GetObj() *C.Evas_Object { return self.obj }

func NewIcon(parent EvasObject) (*Icon) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_icon_add(c_parent)
  return &Icon{obj: _cgo_return_}
}

type Scroller struct { obj *C.Evas_Object }
func (self *Scroller) GetObj() *C.Evas_Object { return self.obj }

func NewScroller(parent EvasObject) (*Scroller) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_scroller_add(c_parent)
  return &Scroller{obj: _cgo_return_}
}

type Entry struct { obj *C.Evas_Object }
func (self *Entry) GetObj() *C.Evas_Object { return self.obj }

func NewEntry(parent EvasObject) (*Entry) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_entry_add(c_parent)
  return &Entry{obj: _cgo_return_}
}

type List struct { obj *C.Evas_Object }
func (self *List) GetObj() *C.Evas_Object { return self.obj }

func NewList(parent EvasObject) (*List) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_list_add(c_parent)
  return &List{obj: _cgo_return_}
}

type Ctxpopup struct { obj *C.Evas_Object }
func (self *Ctxpopup) GetObj() *C.Evas_Object { return self.obj }

func NewCtxpopup(parent EvasObject) (*Ctxpopup) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_ctxpopup_add(c_parent)
  return &Ctxpopup{obj: _cgo_return_}
}

type Dayselector struct { obj *C.Evas_Object }
func (self *Dayselector) GetObj() *C.Evas_Object { return self.obj }

func NewDayselector(parent EvasObject) (*Dayselector) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_dayselector_add(c_parent)
  return &Dayselector{obj: _cgo_return_}
}

type FileselectorButton struct { obj *C.Evas_Object }
func (self *FileselectorButton) GetObj() *C.Evas_Object { return self.obj }

func NewFileselectorButton(parent EvasObject) (*FileselectorButton) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_fileselector_button_add(c_parent)
  return &FileselectorButton{obj: _cgo_return_}
}

type FileselectorEntry struct { obj *C.Evas_Object }
func (self *FileselectorEntry) GetObj() *C.Evas_Object { return self.obj }

func NewFileselectorEntry(parent EvasObject) (*FileselectorEntry) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_fileselector_entry_add(c_parent)
  return &FileselectorEntry{obj: _cgo_return_}
}

type Fileselector struct { obj *C.Evas_Object }
func (self *Fileselector) GetObj() *C.Evas_Object { return self.obj }

func NewFileselector(parent EvasObject) (*Fileselector) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_fileselector_add(c_parent)
  return &Fileselector{obj: _cgo_return_}
}

type Hoversel struct { obj *C.Evas_Object }
func (self *Hoversel) GetObj() *C.Evas_Object { return self.obj }

func NewHoversel(parent EvasObject) (*Hoversel) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_hoversel_add(c_parent)
  return &Hoversel{obj: _cgo_return_}
}

type Multibuttonentry struct { obj *C.Evas_Object }
func (self *Multibuttonentry) GetObj() *C.Evas_Object { return self.obj }

func NewMultibuttonentry(parent EvasObject) (*Multibuttonentry) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_multibuttonentry_add(c_parent)
  return &Multibuttonentry{obj: _cgo_return_}
}

type Naviframe struct { obj *C.Evas_Object }
func (self *Naviframe) GetObj() *C.Evas_Object { return self.obj }

func NewNaviframe(parent EvasObject) (*Naviframe) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_naviframe_add(c_parent)
  return &Naviframe{obj: _cgo_return_}
}

type Popup struct { obj *C.Evas_Object }
func (self *Popup) GetObj() *C.Evas_Object { return self.obj }

func NewPopup(parent EvasObject) (*Popup) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_popup_add(c_parent)
  return &Popup{obj: _cgo_return_}
}

type Actionslider struct { obj *C.Evas_Object }
func (self *Actionslider) GetObj() *C.Evas_Object { return self.obj }

func NewActionslider(parent EvasObject) (*Actionslider) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_actionslider_add(c_parent)
  return &Actionslider{obj: _cgo_return_}
}

type Bg struct { obj *C.Evas_Object }
func (self *Bg) GetObj() *C.Evas_Object { return self.obj }

func NewBg(parent EvasObject) (*Bg) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_bg_add(c_parent)
  return &Bg{obj: _cgo_return_}
}

type Box struct { obj *C.Evas_Object }
func (self *Box) GetObj() *C.Evas_Object { return self.obj }

func NewBox(parent EvasObject) (*Box) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_box_add(c_parent)
  return &Box{obj: _cgo_return_}
}

type Bubble struct { obj *C.Evas_Object }
func (self *Bubble) GetObj() *C.Evas_Object { return self.obj }

func NewBubble(parent EvasObject) (*Bubble) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_bubble_add(c_parent)
  return &Bubble{obj: _cgo_return_}
}

type Button struct { obj *C.Evas_Object }
func (self *Button) GetObj() *C.Evas_Object { return self.obj }

func NewButton(parent EvasObject) (*Button) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_button_add(c_parent)
  return &Button{obj: _cgo_return_}
}

type Calendar struct { obj *C.Evas_Object }
func (self *Calendar) GetObj() *C.Evas_Object { return self.obj }

func NewCalendar(parent EvasObject) (*Calendar) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_calendar_add(c_parent)
  return &Calendar{obj: _cgo_return_}
}

type Check struct { obj *C.Evas_Object }
func (self *Check) GetObj() *C.Evas_Object { return self.obj }

func NewCheck(parent EvasObject) (*Check) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_check_add(c_parent)
  return &Check{obj: _cgo_return_}
}

type Clock struct { obj *C.Evas_Object }
func (self *Clock) GetObj() *C.Evas_Object { return self.obj }

func NewClock(parent EvasObject) (*Clock) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_clock_add(c_parent)
  return &Clock{obj: _cgo_return_}
}

type Colorselector struct { obj *C.Evas_Object }
func (self *Colorselector) GetObj() *C.Evas_Object { return self.obj }

func NewColorselector(parent EvasObject) (*Colorselector) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_colorselector_add(c_parent)
  return &Colorselector{obj: _cgo_return_}
}

type Conformant struct { obj *C.Evas_Object }
func (self *Conformant) GetObj() *C.Evas_Object { return self.obj }

func NewConformant(parent EvasObject) (*Conformant) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_conformant_add(c_parent)
  return &Conformant{obj: _cgo_return_}
}

type Datetime struct { obj *C.Evas_Object }
func (self *Datetime) GetObj() *C.Evas_Object { return self.obj }

func NewDatetime(parent EvasObject) (*Datetime) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_datetime_add(c_parent)
  return &Datetime{obj: _cgo_return_}
}

type Diskselector struct { obj *C.Evas_Object }
func (self *Diskselector) GetObj() *C.Evas_Object { return self.obj }

func NewDiskselector(parent EvasObject) (*Diskselector) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_diskselector_add(c_parent)
  return &Diskselector{obj: _cgo_return_}
}

type Flip struct { obj *C.Evas_Object }
func (self *Flip) GetObj() *C.Evas_Object { return self.obj }

func NewFlip(parent EvasObject) (*Flip) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_flip_add(c_parent)
  return &Flip{obj: _cgo_return_}
}

type Flipselector struct { obj *C.Evas_Object }
func (self *Flipselector) GetObj() *C.Evas_Object { return self.obj }

func NewFlipselector(parent EvasObject) (*Flipselector) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_flipselector_add(c_parent)
  return &Flipselector{obj: _cgo_return_}
}

type Frame struct { obj *C.Evas_Object }
func (self *Frame) GetObj() *C.Evas_Object { return self.obj }

func NewFrame(parent EvasObject) (*Frame) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_frame_add(c_parent)
  return &Frame{obj: _cgo_return_}
}

type Gengrid struct { obj *C.Evas_Object }
func (self *Gengrid) GetObj() *C.Evas_Object { return self.obj }

func NewGengrid(parent EvasObject) (*Gengrid) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_gengrid_add(c_parent)
  return &Gengrid{obj: _cgo_return_}
}

type Genlist struct { obj *C.Evas_Object }
func (self *Genlist) GetObj() *C.Evas_Object { return self.obj }

func NewGenlist(parent EvasObject) (*Genlist) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_genlist_add(c_parent)
  return &Genlist{obj: _cgo_return_}
}

type GestureLayer struct { obj *C.Evas_Object }
func (self *GestureLayer) GetObj() *C.Evas_Object { return self.obj }

func NewGestureLayer(parent EvasObject) (*GestureLayer) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_gesture_layer_add(c_parent)
  return &GestureLayer{obj: _cgo_return_}
}

type Glview struct { obj *C.Evas_Object }
func (self *Glview) GetObj() *C.Evas_Object { return self.obj }

func NewGlview(parent EvasObject) (*Glview) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_glview_add(c_parent)
  return &Glview{obj: _cgo_return_}
}

type Grid struct { obj *C.Evas_Object }
func (self *Grid) GetObj() *C.Evas_Object { return self.obj }

func NewGrid(parent EvasObject) (*Grid) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_grid_add(c_parent)
  return &Grid{obj: _cgo_return_}
}

type Hover struct { obj *C.Evas_Object }
func (self *Hover) GetObj() *C.Evas_Object { return self.obj }

func NewHover(parent EvasObject) (*Hover) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_hover_add(c_parent)
  return &Hover{obj: _cgo_return_}
}

type Image struct { obj *C.Evas_Object }
func (self *Image) GetObj() *C.Evas_Object { return self.obj }

func NewImage(parent EvasObject) (*Image) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_image_add(c_parent)
  return &Image{obj: _cgo_return_}
}

type Index struct { obj *C.Evas_Object }
func (self *Index) GetObj() *C.Evas_Object { return self.obj }

func NewIndex(parent EvasObject) (*Index) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_index_add(c_parent)
  return &Index{obj: _cgo_return_}
}

type WinInwin struct { obj *C.Evas_Object }
func (self *WinInwin) GetObj() *C.Evas_Object { return self.obj }

func NewWinInwin(parent EvasObject) (*WinInwin) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_win_inwin_add(c_parent)
  return &WinInwin{obj: _cgo_return_}
}

type Label struct { obj *C.Evas_Object }
func (self *Label) GetObj() *C.Evas_Object { return self.obj }

func NewLabel(parent EvasObject) (*Label) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_label_add(c_parent)
  return &Label{obj: _cgo_return_}
}

type Layout struct { obj *C.Evas_Object }
func (self *Layout) GetObj() *C.Evas_Object { return self.obj }

func NewLayout(parent EvasObject) (*Layout) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_layout_add(c_parent)
  return &Layout{obj: _cgo_return_}
}

type Map struct { obj *C.Evas_Object }
func (self *Map) GetObj() *C.Evas_Object { return self.obj }

func NewMap(parent EvasObject) (*Map) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_map_add(c_parent)
  return &Map{obj: _cgo_return_}
}

type MapTrack struct { obj *C.Evas_Object }
func (self *MapTrack) GetObj() *C.Evas_Object { return self.obj }

func NewMapTrack(obj EvasObject, emap unsafe.Pointer) (*MapTrack) {
  var c_obj *C.Evas_Object
  if obj != nil { c_obj = obj.GetObj() }
  _cgo_return_ := C.elm_map_track_add(c_obj, emap)
  return &MapTrack{obj: _cgo_return_}
}

type Mapbuf struct { obj *C.Evas_Object }
func (self *Mapbuf) GetObj() *C.Evas_Object { return self.obj }

func NewMapbuf(parent EvasObject) (*Mapbuf) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_mapbuf_add(c_parent)
  return &Mapbuf{obj: _cgo_return_}
}

type Menu struct { obj *C.Evas_Object }
func (self *Menu) GetObj() *C.Evas_Object { return self.obj }

func NewMenu(parent EvasObject) (*Menu) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_menu_add(c_parent)
  return &Menu{obj: _cgo_return_}
}

type Notify struct { obj *C.Evas_Object }
func (self *Notify) GetObj() *C.Evas_Object { return self.obj }

func NewNotify(parent EvasObject) (*Notify) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_notify_add(c_parent)
  return &Notify{obj: _cgo_return_}
}

type Panel struct { obj *C.Evas_Object }
func (self *Panel) GetObj() *C.Evas_Object { return self.obj }

func NewPanel(parent EvasObject) (*Panel) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_panel_add(c_parent)
  return &Panel{obj: _cgo_return_}
}

type Panes struct { obj *C.Evas_Object }
func (self *Panes) GetObj() *C.Evas_Object { return self.obj }

func NewPanes(parent EvasObject) (*Panes) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_panes_add(c_parent)
  return &Panes{obj: _cgo_return_}
}

type Photocam struct { obj *C.Evas_Object }
func (self *Photocam) GetObj() *C.Evas_Object { return self.obj }

func NewPhotocam(parent EvasObject) (*Photocam) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_photocam_add(c_parent)
  return &Photocam{obj: _cgo_return_}
}

type Photo struct { obj *C.Evas_Object }
func (self *Photo) GetObj() *C.Evas_Object { return self.obj }

func NewPhoto(parent EvasObject) (*Photo) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_photo_add(c_parent)
  return &Photo{obj: _cgo_return_}
}

type Plug struct { obj *C.Evas_Object }
func (self *Plug) GetObj() *C.Evas_Object { return self.obj }

func NewPlug(parent EvasObject) (*Plug) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_plug_add(c_parent)
  return &Plug{obj: _cgo_return_}
}

type Progressbar struct { obj *C.Evas_Object }
func (self *Progressbar) GetObj() *C.Evas_Object { return self.obj }

func NewProgressbar(parent EvasObject) (*Progressbar) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_progressbar_add(c_parent)
  return &Progressbar{obj: _cgo_return_}
}

type Radio struct { obj *C.Evas_Object }
func (self *Radio) GetObj() *C.Evas_Object { return self.obj }

func NewRadio(parent EvasObject) (*Radio) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_radio_add(c_parent)
  return &Radio{obj: _cgo_return_}
}

type Route struct { obj *C.Evas_Object }
func (self *Route) GetObj() *C.Evas_Object { return self.obj }

func NewRoute(parent EvasObject) (*Route) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_route_add(c_parent)
  return &Route{obj: _cgo_return_}
}

type SegmentControl struct { obj *C.Evas_Object }
func (self *SegmentControl) GetObj() *C.Evas_Object { return self.obj }

func NewSegmentControl(parent EvasObject) (*SegmentControl) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_segment_control_add(c_parent)
  return &SegmentControl{obj: _cgo_return_}
}

type Separator struct { obj *C.Evas_Object }
func (self *Separator) GetObj() *C.Evas_Object { return self.obj }

func NewSeparator(parent EvasObject) (*Separator) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_separator_add(c_parent)
  return &Separator{obj: _cgo_return_}
}

type Slider struct { obj *C.Evas_Object }
func (self *Slider) GetObj() *C.Evas_Object { return self.obj }

func NewSlider(parent EvasObject) (*Slider) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_slider_add(c_parent)
  return &Slider{obj: _cgo_return_}
}

type Slideshow struct { obj *C.Evas_Object }
func (self *Slideshow) GetObj() *C.Evas_Object { return self.obj }

func NewSlideshow(parent EvasObject) (*Slideshow) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_slideshow_add(c_parent)
  return &Slideshow{obj: _cgo_return_}
}

type Spinner struct { obj *C.Evas_Object }
func (self *Spinner) GetObj() *C.Evas_Object { return self.obj }

func NewSpinner(parent EvasObject) (*Spinner) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_spinner_add(c_parent)
  return &Spinner{obj: _cgo_return_}
}

type Table struct { obj *C.Evas_Object }
func (self *Table) GetObj() *C.Evas_Object { return self.obj }

func NewTable(parent EvasObject) (*Table) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_table_add(c_parent)
  return &Table{obj: _cgo_return_}
}

type Thumb struct { obj *C.Evas_Object }
func (self *Thumb) GetObj() *C.Evas_Object { return self.obj }

func NewThumb(parent EvasObject) (*Thumb) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_thumb_add(c_parent)
  return &Thumb{obj: _cgo_return_}
}

type Toolbar struct { obj *C.Evas_Object }
func (self *Toolbar) GetObj() *C.Evas_Object { return self.obj }

func NewToolbar(parent EvasObject) (*Toolbar) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_toolbar_add(c_parent)
  return &Toolbar{obj: _cgo_return_}
}

type Player struct { obj *C.Evas_Object }
func (self *Player) GetObj() *C.Evas_Object { return self.obj }

func NewPlayer(parent EvasObject) (*Player) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_player_add(c_parent)
  return &Player{obj: _cgo_return_}
}

type Video struct { obj *C.Evas_Object }
func (self *Video) GetObj() *C.Evas_Object { return self.obj }

func NewVideo(parent EvasObject) (*Video) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_video_add(c_parent)
  return &Video{obj: _cgo_return_}
}

type Web struct { obj *C.Evas_Object }
func (self *Web) GetObj() *C.Evas_Object { return self.obj }

func NewWeb(parent EvasObject) (*Web) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  _cgo_return_ := C.elm_web_add(c_parent)
  return &Web{obj: _cgo_return_}
}

type Win struct { obj *C.Evas_Object }
func (self *Win) GetObj() *C.Evas_Object { return self.obj }

func NewWin(parent EvasObject, name string, type_ C.Elm_Win_Type) (*Win) {
  var c_parent *C.Evas_Object
  if parent != nil { c_parent = parent.GetObj() }
  c_name := C.CString(name)
  _cgo_return_ := C.elm_win_add(c_parent, c_name, type_)
  return &Win{obj: _cgo_return_}
}
