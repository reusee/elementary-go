package main

import (
  "strings"
  "log"
  "os"
)

func (self *Generator) collectGeneralMethods() {
  for _, fun := range self.CFuncs {
    if _, has := DISCARD_METHOD_FUNCS[fun.Name]; has { continue }
    for _, prefix := range []string{"elm_object_", "evas_object_"} {
      if strings.HasPrefix(fun.Name, prefix) && len(fun.ParamTypes) > 0 && fun.ParamTypes[0] == "Evas_Object *" {
        name := convertMethodName(fun.Name, prefix)
        for _, class := range self.Classes {
          if method := makeGoMethod(fun, class, name); method != nil {
            for _, m := range class.Methods {
              if m.Name == method.Name {
                log.Fatalf("name collision %s", m.Name)
              }
            }
            class.Methods = append(class.Methods, method)
          }
        }
        fun.Exported = true
      }
    }
  }
}

func (self *Generator) collectClassMethods() {
  for _, class := range self.Classes {
    prefix := class.CConstructor.Name
    prefix = prefix[:len(prefix) - len("add")]
    for _, fun := range self.CFuncs {
      if strings.HasPrefix(fun.Name, prefix) {
        p("%s\n", fun.Name)
        name := convertMethodName(fun.Name, prefix)
        if method := makeGoMethod(fun, class, name); method != nil {
          for _, m := range class.Methods {
            if m.Name == method.Name {
              log.Fatalf("name collision %s", m.Name)
            }
          }
          class.Methods = append(class.Methods, method)
        }
      }
    }
  }
}

func (self *Generator) generateGeneralMethods() {
  outputFile, err := os.Create("../methods.go")
  if err != nil { log.Fatal(err) }
  defer outputFile.Close()
  outputFile.Write([]byte(`package elm // generated by gen/methods.go

//#include <Elementary.h>
import "C"
import (
  "unsafe"
)

`))
  for _, class := range self.Classes {
    for _, method := range class.Methods {
      outputFile.Write([]byte(method.Gen()))
      outputFile.Write([]byte("\n"))
    }
  }
}

func convertMethodName(name string, prefix string) string {
  name = name[len(prefix) : ]
  segs := strings.Split(name, "_")
  for i, s := range segs { segs[i] = strings.Title(s) }
  name = strings.Join(segs, "")
  return name
}

func makeGoMethod(fun *CFunc, class *Class, name string) *BridgeFunc {
  gofunc := new(BridgeFunc)
  gofunc.CFunc = fun
  gofunc.Receiver = "*" + class.Name
  gofunc.Name = name
  gofunc.CgoArguments = append(gofunc.CgoArguments, "self.obj")
  for i, paramName := range fun.ParamNames[1:] {
    paramType := fun.ParamTypes[i + 1]
    if strings.HasSuffix(paramType, "_Cb") || paramName == "cb" { // does not support callback type
      return nil
    }
    if paramType == "va_list" { // does not support va_list
      return nil
    }
    gofunc.ConvertParam(paramName, paramType)
  }
  if fun.ReturnType != "void" {
    gofunc.ConvertReturnType(fun.ReturnType)
  }
  gofunc.CgoFunc = fun.Name
  gofunc.ReturnExpression = "_go_return_"
  return gofunc
}
