package main

import (
  "strings"
  "log"
  "os"
)

func (self *Class) AddMethod(fun *CFunc, prefix string) {
  name := convertMethodName(fun.Name, prefix)
  if method := makeGoMethod(fun, self, name); method != nil {
    self.Methods = append(self.Methods, method)
  }
}

func (self *Generator) collectGeneralMethods() {
  for _, fun := range self.CFuncs {
    if DISCARD_METHOD_FUNCS.Has(fun.Name) { continue }
    for _, prefix := range []string{"elm_object_", "evas_object_"} {
      if strings.HasPrefix(fun.Name, prefix) && len(fun.ParamTypes) > 0 && fun.ParamTypes[0] == "Evas_Object *" {
        for _, class := range self.Classes {
          class.AddMethod(fun, prefix)
        }
        fun.Exported = true
      }
    }
  }
}

func (self *Generator) collectClassMethods() {
  for _, class := range self.Classes {
    prefix := class.CConstructor.Name
    prefix = prefix[:len(prefix) - len("add")]
    for _, fun := range self.CFuncs {
      if DISCARD_METHOD_FUNCS.Has(fun.Name) { continue }
      if strings.HasPrefix(fun.Name, prefix) && len(fun.ParamTypes) > 0 && fun.ParamTypes[0] == "Evas_Object *" {
        class.AddMethod(fun, prefix)
        fun.Exported = true
      }
    }
  }
}

func (self *Generator) generateGeneralMethods() {
  outputFile, err := os.Create("../methods.go")
  if err != nil { log.Fatal(err) }
  defer outputFile.Close()
  outputFile.Write([]byte(`package elm // generated by gen/methods.go

//#include <Elementary.h>
import "C"
import (
  "unsafe"
)

`))
  for _, class := range self.Classes {
    generatedMethods := make(map[string]*BridgeFunc)
    for _, method := range class.Methods {
      if gm, has := generatedMethods[method.Name]; has {
        if modulePrefered(gm.CFunc.Module, method.CFunc.Module) {
          module := method.CFunc.Module
          module = strings.ToUpper(module[:len(module) - 1])
          method.Name = module + method.Name
        } else {
          module := gm.CFunc.Module
          module = strings.ToUpper(module[:len(module) - 1])
          gm.Name = module + gm.Name
        }
        //log.Fatalf("method name collision %s %s %s", class.Name, gm.CFunc.Name, method.CFunc.Name)
      }
      generatedMethods[method.Name] = method
    }
    for _, method := range class.Methods {
      outputFile.Write([]byte(method.Gen()))
      outputFile.Write([]byte("\n"))
    }
  }
}

func convertMethodName(name string, prefix string) string {
  name = name[len(prefix) : ]
  segs := strings.Split(name, "_")
  for i, s := range segs { segs[i] = strings.Title(s) }
  name = strings.Join(segs, "")
  return name
}

func makeGoMethod(fun *CFunc, class *Class, name string) *BridgeFunc {
  gofunc := new(BridgeFunc)
  gofunc.CFunc = fun
  gofunc.Receiver = "*" + class.Name
  gofunc.Name = name
  gofunc.CgoArguments = append(gofunc.CgoArguments, "self.obj")
  if len(fun.ParamNames) > 1 {
    for i, paramName := range fun.ParamNames[1:] {
      paramType := fun.ParamTypes[i + 1]
      if strings.HasSuffix(paramType, "_Cb") || paramName == "cb" { // does not support callback type
        return nil
      }
      if NOT_SUPPORTED_TYPES.Has(paramType) {
        return nil
      }
      if _, has := RETURN_PARAM_MAPPINGS[paramType]; (strings.HasSuffix(fun.Name, "_get") || FUNCS_WITH_RETURN_PARAM.Has(fun.Name)) && has { // return params
        gofunc.ConvertReturnParam(paramName, paramType)
      } else {
        gofunc.ConvertParam(paramName, paramType)
      }
    }
  }
  if NOT_SUPPORTED_TYPES.Has(fun.ReturnType) {
    return nil
  }
  if fun.ReturnType != "void" {
    gofunc.ConvertReturnType(fun.ReturnType)
  }
  gofunc.CgoFunc = fun.Name
  return gofunc
}
