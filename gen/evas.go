package main

import (
  "strings"
  "log"
  "os"
)

func genEvasObjectMethods(funcs []*CFunc, classes []Class) {
  methods := make([]BridgeFunc, 0)
  loopfunc: for _, fun := range funcs {
    if strings.HasPrefix(fun.Name, "evas_object_") && len(fun.ParamTypes) > 0 && fun.ParamTypes[0] == "Evas_Object *" {
      if _, has := DISCARD_METHOD_FUNCS[fun.Name]; has { continue }
      // get go func name
      name := fun.Name[len("evas_object_") : ]
      segs := strings.Split(name, "_")
      for i, s := range segs { segs[i] = strings.Title(s) }
      name = strings.Join(segs, "")
      for _, class := range classes {
        gofunc := BridgeFunc{}
        gofunc.Receiver = "*" + class.Name
        gofunc.Name = name
        gofunc.CgoArguments = append(gofunc.CgoArguments, "self.obj")
        for i, paramName := range fun.ParamNames[1:] {
          paramType := fun.ParamTypes[i + 1]
          if strings.HasSuffix(paramType, "_Cb") || paramName == "cb" { // does not support callback type
            continue loopfunc
          }
          if paramType == "va_list" { // does not support va_list
            continue loopfunc
          }
          gofunc.ConvertParam(paramName, paramType)
        }
        if fun.ReturnType != "void" {
          gofunc.ConvertReturnType(fun.ReturnType)
        }
        gofunc.CgoFunc = fun.Name
        gofunc.ReturnExpression = "_go_return_"
        methods = append(methods, gofunc)
      }
    }
    fun.Exported = true
  }
  // gen code
  outputFile, err := os.Create("../elm_evas_methods.go")
  if err != nil { log.Fatal(err) }
  defer outputFile.Close()
  outputFile.Write([]byte(`package elm // generated by gen/evas.go

//#include <Elementary.h>
import "C"
import (
  "unsafe"
)

`))
  for _, method := range methods {
    outputFile.Write([]byte(method.Gen()))
    outputFile.Write([]byte("\n"))
  }
}
